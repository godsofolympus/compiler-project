package compiler.parser;

import java.util.*;
import java_cup.runtime.*;
import compiler.scanner.*;
import compiler.AST.*;
import compiler.models.*;

// user code components
parser code {:  
                private Lexer scanner;

                public Parser(Lexer scanner) {
                    this.scanner = scanner;
                } 
            :};
scan with {: return scanner.next_token(); :};

// symbol lists
terminal            VOID, INT, DOUBLE, BOOL, STRING;
terminal            CLASS, INTERFACE, THIS, EXTENDS, IMPLEMENTS;
terminal            FOR, WHILE, IF, ELSE, RETURN, BREAK, CONTINUE;
terminal            NEW, NEW_ARRAY, PRINT, READ_INTEGER, READ_LINE;
terminal            DTOI, ITOD, BTOI, ITOB;
terminal            PRIVATE, PROTECTED, PUBLIC, IMPORT;

terminal            PLUS, MINUS, MULTIPLY, DIVIDE, MOD;
terminal            UMINUS, NOT;
terminal            LESS, LESS_EQUAL, GREATER, GREATER_EQUAL, EQUAL, EQUAL_EQUAL, NOT_EQUAL, OR_OR, AND_AND;
terminal            SEMICOLON, COMMA, DOT, BRACKETS_LEFT_RIGHT, BRACKETS_LEFT, BRACKETS_RIGHT, PARANTHESIS_LEFT, PARANTHESIS_RIGHT, CURLY_BRACKETS_LEFT,
                    CURLY_BRACKETS_RIGHT;

terminal Integer    INT_CONSTANT;
terminal Double     DOUBLE_CONSTANT;
terminal Boolean    BOOL_CONSTANT;
terminal String     STRING_CONSTANT;
terminal             NULL;

terminal String     IDENTIFIER;


non terminal Program Program;
non terminal Decl Decl;
non terminal LinkedList<Decl> DeclStar;
non terminal LinkedList<Variable> VariableDeclStar;
non terminal Variable VariableDecl;
non terminal Variable Variable;
non terminal Type Type;
non terminal Primitive PrimitiveType;
non terminal LinkedList<Variable> Formals;
non terminal StmtBlock StmtBlock;
non terminal StmtBlock InsideStmtBlock;
non terminal LinkedList<Stmt> StmtStar;
non terminal Stmt Stmt;
non terminal Decl FunctionDecl;

non terminal        Macro, MacroStar, ClassDecl, Field, AccessMode,
                    InterfaceDecl, Prototype, IfStmt, WhileStmt, ForStmt, ReturnStmt, BreakStmt, ContinueStmt,
                    PrintStmt, Actuals;

non terminal        ClassDeclExtends, ClassDeclImplements, ClassDeclFields, IdentifierStar, PrototypeStar,
                    ExprOptional, ElseStmtOptional , ExprPlusComma;

non terminal Object Constant;
non terminal Object LValue;
non terminal Object Expr;
non terminal Object Call;

// precedence and associativity declarations
precedence left ELSE;
precedence right EQUAL;
precedence left OR_OR;
precedence left AND_AND;
precedence left EQUAL_EQUAL, NOT_EQUAL;
precedence left LESS, LESS_EQUAL, GREATER, GREATER_EQUAL;
precedence left PLUS, MINUS;
precedence left MULTIPLY, DIVIDE, MOD;
precedence right NOT, UMINUS;
precedence left BRACKETS_LEFT, DOT;
precedence left PARANTHESIS_LEFT;

// the grammar
start with Program;

Program ::= MacroStar Decl:d DeclStar:ds    {: ds.add(d); RESULT = new Program(ds); :};

Macro ::= IMPORT STRING_CONSTANT;
MacroStar ::= Macro MacroStar | /* epsilon */;

Decl
    ::= VariableDecl:v {: RESULT = Decl.variableDecl(v); :}
    | FunctionDecl:f {: RESULT = f; :}
    | ClassDecl {: RESULT = Decl.classDecl(); :}
    | InterfaceDecl {: RESULT = Decl.interfaceDecl(); :}
    ;

DeclStar
    ::= Decl:d DeclStar:ds   {: ds.add(d); RESULT = ds; :}
    |   {: RESULT = new LinkedList<Decl>(); :}
    ;

VariableDeclStar
    ::= VariableDecl:v VariableDeclStar:vs {: vs.add(v); RESULT = vs; :}
    |   {:RESULT = new LinkedList<Variable>(); :}
    ;

VariableDecl        ::= Variable:v SEMICOLON {: RESULT = v; :};
Variable            ::= Type:t IDENTIFIER:id {: RESULT = new Variable(t, id); :};

PrimitiveType
    ::= INT {: RESULT = Primitive.INT; :}
    | DOUBLE {: RESULT = Primitive.DOUBLE; :}
    | BOOL {: RESULT = Primitive.BOOL; :}
    | STRING {: RESULT = Primitive.STRING; :}
    ;

Type
    ::= PrimitiveType:pt {: RESULT = Type.primitiveType(pt); :}
    | IDENTIFIER:id {: RESULT =  Type.nonPrimitiveType(id); :}
    | Type:t BRACKETS_LEFT_RIGHT {: RESULT = Type.arrayType(t); :}
    ;

FunctionDecl
    ::= Type:t IDENTIFIER:id PARANTHESIS_LEFT Formals:f PARANTHESIS_RIGHT StmtBlock:sb {: RESULT = Decl.functionDecl(id, t, f, sb); :}
    |   VOID IDENTIFIER:id PARANTHESIS_LEFT Formals:f PARANTHESIS_RIGHT StmtBlock:sb {: RESULT = Decl.functionDecl(id, null, f, sb); :}
    ;

Formals
    ::= Variable:v {: LinkedList<Variable> list = new LinkedList<>(); list.add(v); RESULT = list; :}
    | Formals:f COMMA Variable:v {: f.add(v); RESULT = f; :}
    | {: RESULT = new LinkedList<Variable>(); :} /* epsilon */
    ;

ClassDecl           ::= CLASS IDENTIFIER ClassDeclExtends ClassDeclImplements CURLY_BRACKETS_LEFT ClassDeclFields CURLY_BRACKETS_RIGHT;
ClassDeclExtends    ::= EXTENDS IDENTIFIER | /* epsilon */ ;
ClassDeclImplements ::= IMPLEMENTS IdentifierStar | /* epsilon */ ;
IdentifierStar      ::= IDENTIFIER | IdentifierStar COMMA IDENTIFIER;
ClassDeclFields     ::= ClassDeclFields Field | /* epsilon */ ;
Field               ::= AccessMode VariableDecl | AccessMode FunctionDecl;
AccessMode          ::= PRIVATE | PROTECTED | PUBLIC | /* epsilon */ ;
InterfaceDecl       ::= INTERFACE IDENTIFIER CURLY_BRACKETS_LEFT PrototypeStar CURLY_BRACKETS_RIGHT;
PrototypeStar       ::= PrototypeStar Prototype | /* epsilon */ ;
Prototype           ::= Type IdentifierStar PARANTHESIS_LEFT Formals PARANTHESIS_RIGHT SEMICOLON |
                        VOID IdentifierStar PARANTHESIS_LEFT Formals PARANTHESIS_RIGHT SEMICOLON;
StmtBlock           ::= CURLY_BRACKETS_LEFT InsideStmtBlock:sb CURLY_BRACKETS_RIGHT {: RESULT = sb; :};

InsideStmtBlock     ::= VariableDeclStar:vs StmtStar:ss {: RESULT = new StmtBlock(vs, ss); :};

StmtStar
    ::= Stmt:s StmtStar:ss {: ss.add(s); RESULT = ss; :}
    | {: RESULT = new LinkedList<Stmt>(); :}/* epsilon */
    ;

Stmt
    ::= ExprOptional SEMICOLON {: RESULT = Stmt.exprStmt(); :}
    | IfStmt {: RESULT = Stmt.ifStmt(); :}
    | WhileStmt {: RESULT = Stmt.whileStmt(); :}
    | ForStmt {: RESULT = Stmt.forStmt(); :}
    | BreakStmt {: RESULT = Stmt.breakStmt(); :}
    | ContinueStmt {: RESULT = Stmt.continueStmt(); :}
    | ReturnStmt {: RESULT = Stmt.returnStmt(); :}
    | PrintStmt {: RESULT = Stmt.printStmt(); :}
    | StmtBlock {: RESULT = Stmt.blockStmt(); :}
    ;

ExprOptional        ::= Expr | /* epsilon */ ;
IfStmt              ::= IF PARANTHESIS_LEFT Expr PARANTHESIS_RIGHT Stmt ElseStmtOptional;
ElseStmtOptional    ::= ELSE Stmt | /* epsilon */ ;
WhileStmt           ::= WHILE PARANTHESIS_LEFT Expr PARANTHESIS_RIGHT Stmt;
ForStmt             ::= FOR PARANTHESIS_LEFT ExprOptional SEMICOLON Expr SEMICOLON ExprOptional PARANTHESIS_RIGHT Stmt;
ReturnStmt          ::= RETURN ExprOptional SEMICOLON;
BreakStmt           ::= BREAK SEMICOLON;
ContinueStmt        ::= CONTINUE SEMICOLON;
PrintStmt           ::= PRINT PARANTHESIS_LEFT ExprPlusComma PARANTHESIS_RIGHT SEMICOLON;
ExprPlusComma       ::= Expr | ExprPlusComma COMMA Expr;
Expr                ::= LValue EQUAL Expr | Constant | LValue | THIS | Call | PARANTHESIS_LEFT Expr PARANTHESIS_RIGHT |
                        Expr PLUS Expr | Expr MINUS Expr | Expr MULTIPLY Expr | Expr DIVIDE Expr |
                        Expr MOD Expr | MINUS Expr | Expr LESS Expr | Expr LESS_EQUAL Expr |
                        Expr GREATER Expr | Expr GREATER_EQUAL Expr | Expr EQUAL_EQUAL Expr | Expr NOT_EQUAL Expr |
                        Expr AND_AND Expr | Expr OR_OR Expr | NOT Expr | READ_INTEGER PARANTHESIS_LEFT PARANTHESIS_RIGHT |
                        READ_LINE PARANTHESIS_LEFT PARANTHESIS_RIGHT | NEW IDENTIFIER | NEW_ARRAY PARANTHESIS_LEFT Expr COMMA Type PARANTHESIS_RIGHT |
                        ITOD PARANTHESIS_LEFT Expr PARANTHESIS_RIGHT | DTOI PARANTHESIS_LEFT Expr PARANTHESIS_RIGHT |
                        ITOB PARANTHESIS_LEFT Expr PARANTHESIS_RIGHT | BTOI PARANTHESIS_LEFT Expr PARANTHESIS_RIGHT;
LValue              ::= IDENTIFIER | Expr DOT IDENTIFIER | Expr BRACKETS_LEFT Expr BRACKETS_RIGHT;
Call                ::= IDENTIFIER PARANTHESIS_LEFT Actuals PARANTHESIS_RIGHT | Expr DOT IDENTIFIER PARANTHESIS_LEFT Actuals PARANTHESIS_RIGHT;
Actuals             ::= ExprPlusComma | /* epsilon */ ;
Constant            ::= INT_CONSTANT | DOUBLE_CONSTANT | BOOL_CONSTANT | STRING_CONSTANT | NULL;